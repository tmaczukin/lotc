# Declare used images
add_image :db,  'mysql:5.5-1'
add_image :pma, 'phpmyadmin:4.0'
add_image :app, 'app:1.3'


# Define containers
define_container :db_container do |manifest|
  detach   true                                       # run in detached mode
  volume   '/var/lib/mysql', '/srv/docker/app1/mysql' # add volume binding
  tcp_port 3306, 3306, '127.0.0.5'                    # add port binding
  image    :db                                        # set image

  # set command
  cmd      'create_db_and_run', manifest.envs[:db_name], manifest.envs[:db_user], manifest.envs[:db_pass]
end

define_container :pma_container do |manifest|
  detach   true
  link     :db, :db_container, /^DB started!$/ # add link
  tcp_port 80, 8080, '127.0.0.5'
  image    :pma
end

define_container :app_container do |manifest|
  detach   true
  link     :db, :db_container, /^DB started!$/
  env      'DB_NAME', manifest.envs[:db_name]                 # add env
  env      'DB_USER', manifest.envs[:db_user]                 # add env
  env      'DB_BASS', manifest.envs[:db_pass]                 # add env
  env      'APPLICATION_ENV', manifest.envs[:application_env] # add env
  volume   '/home/app/data', '/srv/docker/app1/app_data'
  tcp_port 80, 80, '127.0.0.5'
  image    :app
end

# Define container extending previously defined container
define_container :db_container_tests, :db_container do
  volume   '/var/lib/mysql', nil # overwrite volume binding for '/var/lib/mysql' container path
  tcp_port 3306, nil             # overwrite port binding (disable)
end

define_container :app_container_tests, :app_container do |manifest|
  detach   false
  remove   true
  link     :db, :db_container_tests, /^DB started!$/
  volume   '/home/app/data', nil
  tcp_port 80, nil
  cmd      manifest.param[:cmd]
end


# Define stages
define_stage :production do
  # Define manifest envs
  env 'DB_NAME', 'app1'
  env 'DB_USER', 'app1_user'
  env 'DB_PASS', 'app1_pass'
  env 'APPLICATION_ENV', 'production'

  # Define containers stack
  #
  # Stack containes only basic-level containers.
  # Rest of stack is defined by links between containers.
  stack :app, :app_container
  stack :tests, :app_container_tests
end

# Define stage extending previously defined stage
define_stage :development, :production do
  env 'APPLICATION_ENV', 'development' # overwrite env
  env 'DOMAIN', 'app1.dev'

  stack :app, :app_container, :pma_container # overwrite stack
end

define_stage :testing, :development do
  env 'APPLICATION_ENV', 'testing'
end


# Define tasks
#
# Each task can be run in each stage.
# The configuration is loaded properly.
define_task :start do

  # Generate containers stack and run containers in valid order.
  # Output contains live-updated output of first container in stack.
  run_containers_stack :app do |output|
    if output.match /^Application started!$/
      puts 'Application started'
      return
    end
  end
end

define_task :stop do

  # Like run_containers_stack but stops containers in valid order
  stop_containers_stack :app do
    puts 'Application stoped'
  end
end

define_task :hard_restart do
  # Iterates over containers in stack
  #
  # You can filter collection providing defined containers as a splat.
  containers_stack :app, :app_container do |container|
    container.exec('send-shutdown-notification')
    sleep(900)
  end

  # Invoke defined task with current stage
  invoke :stop
  invoke :start
end

define_task :restart do
  containers_stack :app, :app_container do |container|
    # Runs `docker exec` on container
    container.exec('send-shutdown-notification')
    sleep(900)
  end

  # Runs `docker restart` on each container in stack in valid order
  restart_containers_stack :app do |output|
    if output.match /^Application started!$/
      puts 'Application restarted'
      return
    end
  end
end

define_task :status do
  containers_stack :app do |c|
    # Gets container
    container.status do |s|
      puts "ID: #{s.id}\tNAME: #{s.name}\tIMAGE: #{s.image.name}\nCREATED: #{s.created}\tSTATUS: #{s.status}\n"
    end
  end
end

define_task :cmd do
  containers_stack :app, :app_container do |container|
    # container.exec can accept block - block is yelded with live-output stream
    container.exec('ls', '-ls') do |output|
      puts output
    end
  end
end

define_task :test do
  # You can set manifest params for each task
  param :cmd, 'test-application', '--verbose'

  run_containers_stack :tests do |output|
    puts output
  end
end

define_task :spec do
  param :cmd, 'spec-application', '--quiet'

  run_containers_stack :tests do |output|
    puts output
  end
end

define_task :backup do
  containers_stack :app, :app_container do |container|
    container.exec('send-shutdown-notification')
    sleep(900)
    stop_containers_stack :app

    # (...) some data backup code here

    start_containers_stack :app

    # (...) some notifications sending code here
  end
end


# Define deploys
#
# Deploy send configuration via SSH connection and run commands on remote agent.
#
# All configurations (manifests and image archives, if uploaded as tars) are preserved,
# so You can rollback to previously used version.
#
# warning - DB migrations and similar issues you must resolve on your own!
#           LOTC is managing containers - not application inside of them!
define_deploy :production do
  host      'prod.app1.com' # remote ssh host
  port      2222            # remote ssh port
  user      'app1-user'     # remote user
  via       :upload         # upload all defined image as tar archives
  keep_last 5               # keep last 5 deploys in archive

  # connect with remote agent and run commands on it
  agent 'unix:///var/run/nazgul.sock' do |agent|
    agent.task :hard_restart, :production # run ':hard_restart' task with ':production' environment
  end
end

define_deploy :staging do
  host      'staging.app1.com'
  port      2222
  user      'app1-user'
  via       :pull       # use standard `docker pull` for all defined images
  keep_last 3

  agent 'tcp://127.0.0.1:1234' do |agent|
    agent.run :hard_restart, :production
  end
end

# LOTC is bundled with two executables: lotc and lotc-agent.
#
# lotc is a CLI util - You can deploy configuration and execute defined tasks whit it.
#                      It is also used to run defined deploys.
#
# lotc-agent is remote daemon - It is used by deploy to manage versions and execute tasks.
#                               While deploying CLI util is connecting with agent and through
#                               it uploads or pulls images and executes defined tasks.
#
#
# Both tools use manifest files to define configuration.
# But - if You want - You can prepare configuration
# and/or execute tasks and deploys programatically.
